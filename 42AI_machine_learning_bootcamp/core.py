# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['sum_', 'mean_', 'variance', 'std', 'dot', 'mat_vec_prod', 'mat_mat_prod', 'mse', 'vec_mse', 'linear_mse',
           'vec_linear_mse', 'gradient', 'vec_gradient', 'predict_', 'cost_elem_', 'cost_']

# Cell
def sum_(x, f):
    if not isinstance(x, np.ndarray) or x.size == 0 or not callable(f):
        return None
    result = 0.0
    for element in x:
        result += f(element)
    return result

# Cell
def mean_(x):
    if not isinstance(x, np.ndarray) or x.size == 0:
        return None
    return sum_(x, lambda x: x) / x.size

# Cell
def variance(x):
    if not isinstance(x, np.ndarray) or x.size == 0:
        return None
    return mean_((x - mean_(x))**2)

# Cell
from math import sqrt


def std(x):
    if not isinstance(x, np.ndarray) or x.size == 0:
        return None
    return sqrt((variance(x)))

# Cell
def dot(x, y):
    if (not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray) or
            x.size == 0 or y.size == 0 or x.size != y.size):
        print("Error: dot")
        return None
    result = 0
    for i in range(x.size):
        result += x[i] * y[i]
    return result

# Cell
def mat_vec_prod(m, x):
    if (not isinstance(m, np.ndarray) or not isinstance(x, np.ndarray) or
            m.size == 0 or m.shape[1] != x.size):
        print("Error: mat_vec_prod")
        return None
    result = np.array([], dtype='int')
    for row in m:
        result = np.append(result, dot(x, row))
    return result.reshape((m.shape[0], 1))

# Cell
def mat_mat_prod(m1, m2):
    if (not isinstance(m1, np.ndarray) or not isinstance(m2, np.ndarray) or
            m1.size == 0 or m1.shape[1] != m2.shape[0]):
        return None
    result = np.zeros((m1.shape[0], m2.shape[1]), dtype='int')
    for column in range(m2.shape[1]):
        result[:, column] = list(mat_vec_prod(m1, np.array(m2[:, column])))
    return result

# Cell
def mse(x, y):
    if (not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray) or
            x.size == 0 or y.size == 0 or x.shape[0] != y.shape[0] or
            x.ndim != 1 or y.ndim != 1):
        return None
    return mean_(np.subtract(x, y)**2)

# Cell
def vec_mse(y, y_hat):
    if (not isinstance(y, np.ndarray)
            or not isinstance(y_hat, np.ndarray)
            or y.size == 0 or y_hat.size == 0
            or y.shape[0] != y_hat.shape[0]
            or y.size != y_hat.size):
        return None
    return dot(np.subtract(y_hat, y), np.subtract(y_hat, y)) / y.size

# Cell
def linear_mse(x, y, theta):
    if (not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray)
            or not isinstance(theta, np.ndarray) or x.size == 0 or y.size == 0
            or theta.size == 0 or len(y.shape) != 1 or len(theta.shape) != 1
            or x.shape[0] != y.size or x.shape[1] != theta.size):
        return None
    result = 0.0
    h = np.zeros(x.shape[0])
    for row in range(x.shape[0]):
        h[row] = dot(x[row], theta)
    return mse(y, h)

# Cell
def vec_linear_mse(x, y, theta):
    if (not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray)
            or not isinstance(theta, np.ndarray) or x.size == 0 or y.size == 0
            or theta.size == 0 or len(y.shape) != 1 or len(theta.shape) != 1
            or x.shape[0] != y.size or x.shape[1] != theta.size):
        return None
    h = np.zeros(x.shape[0])
    for row in range(x.shape[0]):
        h[row] = dot(x[row], theta)
    return dot(np.subtract(y, h), np.subtract(y, h)) / y.size

# Cell
def gradient(x, y, theta):
    if (not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray)
            or not isinstance(theta, np.ndarray) or x.size == 0 or y.size == 0
            or theta.size == 0 or len(y.shape) != 1 or len(theta.shape) != 1
            or x.shape[0] != y.size or x.shape[1] != theta.size):
        return None
    h = np.zeros(x.shape[0])
    for row in range(x.shape[0]):
        h[row] = dot(x[row], theta)
    result = np.zeros(x.shape[1])
    for column in range(x.shape[1]):
        for row in range(x.shape[0]):
            result[column] += (h[row] - y[row]) * x[row][column] / x.shape[0]
    return result

# Cell
def vec_gradient(x, y, theta):
    if (not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray)
            or not isinstance(theta, np.ndarray) or x.size == 0 or y.size == 0
            or theta.size == 0 or len(y.shape) != 1 or len(theta.shape) != 1
            or x.shape[0] != y.size or x.shape[1] != theta.size):
        return None
    h = np.zeros(x.shape[0])
    for row in range(x.shape[0]):
        h[row] = dot(x[row], theta)
    result = mat_vec_prod(x.transpose(), np.subtract(h, y)) / x.shape[0]
    return result.reshape(1, x.shape[1])

# Cell
def predict_(theta, X):
    if (not isinstance(X, np.ndarray) or not isinstance(theta, np.ndarray)
            or X.size == 0 or theta.size == 0 or theta.shape[1] != 1):
        return None
    if theta.shape[0] - 1 != X.shape[1]:
        print("Incompatible dimension match between X and theta.")
        return None
    X = np.insert(X, 0, 1, axis=1)
    return mat_vec_prod(X, theta)

# Cell
def cost_elem_(theta, X, Y):
    if (not isinstance(theta, np.ndarray) or not isinstance(X, np.ndarray)
            or not isinstance(Y, np.ndarray)):
        return None
    J_elem = np.zeros((X.shape[0], 1))
    return J_elem

def cost_(theta, X, Y):
    J_value = 0.0
    return J_value